"""
topic.py - Topic and Category Management Model

This module defines models for topic modeling, categorization, and content organization.
This includes:
- Topic extraction and modeling
- Content categorization and tagging
- Hierarchical taxonomy management
- Topic clustering and similarity
- Trend analysis and topic evolution
- Content recommendation based on topics
- User interest profiling

Key Features:
- Hierarchical topic structures
- Automated topic extraction
- Content-topic association
- Topic similarity and clustering
- Trend detection and analysis
- User-topic affinity modeling
- Multilingual topic support
- Topic validation and quality control
"""

import uuid
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any, TYPE_CHECKING
from enum import Enum
from sqlalchemy import (
    Column, String, Text, ForeignKey, Integer, DateTime, 
    Boolean, Enum as SQLEnum, JSON, Float, CheckConstraint,
    Index, Table, UniqueConstraint, LargeBinary
)
from sqlalchemy.orm import relationship, validates
from sqlalchemy.dialects.postgresql import UUID, JSONB, ARRAY
from sqlalchemy.sql import func, expression
from sqlalchemy.ext.hybrid import hybrid_property

from db.base import Base
from models.mixins import TimestampMixin, UUIDMixin

if TYPE_CHECKING:
    from models.user import User
    from models.article import Article
    from models.incident import Incident
    from models.comment import Comment
    from models.dataset import Dataset
    from models.organization import Organization


class TopicType(Enum):
    """Types of topics."""
    CATEGORY = "category"            # Broad category
    SUBJECT = "subject"              # Subject matter
    THEME = "theme"                  # Thematic topic
    EVENT = "event"                  # Event-based topic
    ENTITY = "entity"                # Named entity
    CONCEPT = "concept"              # Abstract concept
    LOCATION = "location"            # Geographic location
    PERSON = "person"                # Person/individual
    ORGANIZATION = "organization"    # Organization
    TECHNOLOGY = "technology"        # Technology/software
    INDUSTRY = "industry"            # Industry/sector
    HASHTAG = "hashtag"              # Social media hashtag
    KEYWORD = "keyword"              # Search keyword
    CUSTOM = "custom"                # Custom topic type


class TopicStatus(Enum):
    """Topic status."""
    ACTIVE = "active"                # Active topic
    PENDING = "pending"              # Pending review
    REJECTED = "rejected"            # Rejected
    ARCHIVED = "archived"            # Archived
    DEPRECATED = "deprecated"        # Deprecated (no longer used)
    MERGED = "merged"                # Merged into another topic
    DUPLICATE = "duplicate"          # Duplicate topic


class TopicSource(Enum):
    """Sources of topic creation."""
    MANUAL = "manual"                # Manually created
    AUTOMATED = "automated"          # Automatically extracted
    IMPORTED = "imported"            # Imported from external source
    USER_GENERATED = "user_generated"  # Generated by users
    SYSTEM_GENERATED = "system_generated"  # Generated by system
    API = "api"                      # Created via API


class ContentType(Enum):
    """Types of content that can be associated with topics."""
    ARTICLE = "article"              # Articles
    INCIDENT = "incident"            # Incidents
    COMMENT = "comment"              # Comments
    DATASET = "dataset"              # Datasets
    USER = "user"                    # Users
    ORGANIZATION = "organization"    # Organizations
    FILE = "file"                    # Files
    OTHER = "other"                  # Other content types


class Topic(Base, UUIDMixin, TimestampMixin):
    """
    Topic model for categorization and content organization.
    
    This model represents topics that can be used to categorize
    and organize content across the platform.
    
    Attributes:
        id: Primary key UUID
        name: Topic name
        slug: URL-friendly topic identifier
        description: Topic description
        type: Topic type
        status: Topic status
        source: Topic source
        parent_topic_id: Parent topic for hierarchy
        depth: Depth in hierarchy (0 for root)
        language: Topic language code
        synonyms: Alternative names/synonyms
        keywords: Related keywords
        weight: Topic weight/importance
        popularity_score: Popularity score (0-100)
        relevance_score: Relevance score (0-100)
        is_featured: Whether topic is featured
        is_sensitive: Whether topic is sensitive
        color: Color code for visualization
        icon: Icon name or URL
        image_url: Topic image URL
        metadata: Additional metadata
        tags: Categorization tags
        created_by: User who created topic
        reviewed_by: User who reviewed topic
        reviewed_at: When topic was reviewed
        organization_id: Owning organization
    """
    
    __tablename__ = "topics"
    
    # Basic information
    name = Column(String(200), nullable=False, index=True)
    slug = Column(String(100), nullable=False, unique=True, index=True)
    description = Column(Text, nullable=True)
    type = Column(SQLEnum(TopicType), nullable=False, index=True)
    status = Column(SQLEnum(TopicStatus), default=TopicStatus.PENDING, nullable=False, index=True)
    source = Column(SQLEnum(TopicSource), default=TopicSource.MANUAL, nullable=False, index=True)
    
    # Hierarchy
    parent_topic_id = Column(
        UUID(as_uuid=True), 
        ForeignKey("topics.id", ondelete="SET NULL"), 
        nullable=True,
        index=True
    )
    depth = Column(Integer, default=0, nullable=False, index=True)
    
    # Language and variations
    language = Column(String(10), default="en", nullable=False, index=True)
    synonyms = Column(ARRAY(String), default=[], nullable=False)
    keywords = Column(ARRAY(String), default=[], nullable=False, index=True)
    
    # Scoring and ranking
    weight = Column(Float, default=1.0, nullable=False)
    popularity_score = Column(Float, default=0.0, nullable=False, index=True)
    relevance_score = Column(Float, default=0.0, nullable=False, index=True)
    trend_score = Column(Float, default=0.0, nullable=False, index=True)
    
    # Flags
    is_featured = Column(Boolean, default=False, nullable=False, index=True)
    is_sensitive = Column(Boolean, default=False, nullable=False, index=True)
    is_nsfw = Column(Boolean, default=False, nullable=False, index=True)
    
    # Visual representation
    color = Column(String(7), nullable=True)  # Hex color code
    icon = Column(String(100), nullable=True)
    image_url = Column(String(2000), nullable=True)
    banner_url = Column(String(2000), nullable=True)
    
    # Metadata
    metadata = Column(JSONB, default=dict, nullable=False)
    tags = Column(ARRAY(String), default=[], nullable=False, index=True)
    
    # Ownership and review
    created_by = Column(
        UUID(as_uuid=True), 
        ForeignKey("users.id", ondelete="SET NULL"), 
        nullable=True,
        index=True
    )
    reviewed_by = Column(
        UUID(as_uuid=True), 
        ForeignKey("users.id", ondelete="SET NULL"), 
        nullable=True,
        index=True
    )
    reviewed_at = Column(DateTime(timezone=True), nullable=True)
    
    # Organization scope
    organization_id = Column(
        UUID(as_uuid=True), 
        ForeignKey("organizations.id", ondelete="SET NULL"), 
        nullable=True,
        index=True
    )
    
    # Relationships
    parent_topic = relationship("Topic", remote_side=[id], backref="child_topics")
    creator = relationship("User", foreign_keys=[created_by])
    reviewer = relationship("User", foreign_keys=[reviewed_by])
    organization = relationship("Organization")
    
    # Content associations
    articles = relationship("Article", secondary="article_topics", back_populates="topics")
    incidents = relationship("Incident", secondary="incident_topics", back_populates="topics")
    comments = relationship("Comment", secondary="comment_topics", back_populates="topics")
    datasets = relationship("Dataset", secondary="dataset_topics", back_populates="topics")
    
    # Related models
    topic_aliases = relationship("TopicAlias", back_populates="topic", cascade="all, delete-orphan")
    topic_relationships = relationship("TopicRelationship", foreign_keys="TopicRelationship.source_topic_id", back_populates="source_topic")
    related_topic_relationships = relationship("TopicRelationship", foreign_keys="TopicRelationship.target_topic_id", back_populates="target_topic")
    user_interests = relationship("UserTopicInterest", back_populates="topic", cascade="all, delete-orphan")
    content_associations = relationship("ContentTopic", back_populates="topic", cascade="all, delete-orphan")
    cluster_memberships = relationship("TopicClusterMember", back_populates="topic", cascade="all, delete-orphan")
    
    # Check constraints
    __table_args__ = (
        CheckConstraint(
            'slug ~* \'^[a-z0-9]+(?:-[a-z0-9]+)*$\'',
            name='check_topic_slug_format'
        ),
        CheckConstraint('depth >= 0', name='check_depth_non_negative'),
        CheckConstraint('weight >= 0', name='check_weight_non_negative'),
        CheckConstraint('popularity_score >= 0 AND popularity_score <= 100', name='check_popularity_score_range'),
        CheckConstraint('relevance_score >= 0 AND relevance_score <= 100', name='check_relevance_score_range'),
        CheckConstraint('trend_score >= -100 AND trend_score <= 100', name='check_trend_score_range'),
        Index('ix_topics_parent_depth', 'parent_topic_id', 'depth'),
        Index('ix_topics_type_status', 'type', 'status'),
        Index('ix_topics_language_status', 'language', 'status'),
        Index('ix_topics_org_status', 'organization_id', 'status'),
    )
    
    def __repr__(self) -> str:
        """String representation."""
        return f"<Topic(id={self.id}, name={self.name}, type={self.type.value})>"
    
    @property
    def is_active(self) -> bool:
        """Check if topic is active."""
        return self.status == TopicStatus.ACTIVE
    
    @property
    def is_pending_review(self) -> bool:
        """Check if topic is pending review."""
        return self.status == TopicStatus.PENDING
    
    @property
    def is_reviewed(self) -> bool:
        """Check if topic has been reviewed."""
        return self.reviewed_at is not None
    
    @property
    def is_root(self) -> bool:
        """Check if topic is a root topic (no parent)."""
        return self.parent_topic_id is None
    
    @property
    def is_leaf(self) -> bool:
        """Check if topic is a leaf topic (no children)."""
        return len(self.child_topics) == 0
    
    @property
    def child_count(self) -> int:
        """Get number of child topics."""
        return len(self.child_topics)
    
    @property
    def descendant_count(self) -> int:
        """Get total number of descendant topics."""
        count = self.child_count
        for child in self.child_topics:
            count += child.descendant_count
        return count
    
    @property
    def content_count(self) -> int:
        """Get total content associated with this topic."""
        return (
            len(self.articles) + 
            len(self.incidents) + 
            len(self.comments) + 
            len(self.datasets)
        )
    
    @property
    def full_path(self) -> str:
        """Get full topic path in hierarchy."""
        if not self.parent_topic:
            return self.name
        return f"{self.parent_topic.full_path} â€º {self.name}"
    
    @property
    def path_slugs(self) -> List[str]:
        """Get list of slugs in hierarchy path."""
        if not self.parent_topic:
            return [self.slug]
        return self.parent_topic.path_slugs + [self.slug]
    
    @property
    def all_keywords(self) -> List[str]:
        """Get all keywords including synonyms."""
        keywords = set(self.keywords)
        keywords.add(self.name.lower())
        keywords.update([s.lower() for s in self.synonyms])
        return list(keywords)
    
    @property
    def overall_score(self) -> float:
        """Calculate overall topic score."""
        return (
            self.popularity_score * 0.4 +
            self.relevance_score * 0.3 +
            self.trend_score * 0.3
        )
    
    @validates('slug')
    def validate_slug(self, key: str, slug: str) -> str:
        """Validate topic slug."""
        slug = slug.strip().lower()
        if not slug:
            raise ValueError("Topic slug cannot be empty")
        if len(slug) > 100:
            raise ValueError("Topic slug cannot exceed 100 characters")
        import re
        if not re.match(r'^[a-z0-9]+(?:-[a-z0-9]+)*$', slug):
            raise ValueError("Topic slug can only contain lowercase letters, numbers, and hyphens")
        return slug
    
    @validates('name')
    def validate_name(self, key: str, name: str) -> str:
        """Validate topic name."""
        name = name.strip()
        if not name:
            raise ValueError("Topic name cannot be empty")
        if len(name) > 200:
            raise ValueError("Topic name cannot exceed 200 characters")
        return name
    
    def add_synonym(self, synonym: str) -> None:
        """Add a synonym to the topic."""
        synonym_clean = synonym.strip().lower()
        if synonym_clean and synonym_clean not in self.synonyms:
            self.synonyms = self.synonyms + [synonym_clean]
    
    def add_keyword(self, keyword: str) -> None:
        """Add a keyword to the topic."""
        keyword_clean = keyword.strip().lower()
        if keyword_clean and keyword_clean not in self.keywords:
            self.keywords = self.keywords + [keyword_clean]
    
    def approve(self, reviewed_by: 'User', notes: Optional[str] = None) -> None:
        """Approve the topic."""
        self.status = TopicStatus.ACTIVE
        self.reviewed_by = reviewed_by.id
        self.reviewed_at = datetime.utcnow()
        if notes:
            if "review_notes" not in self.metadata:
                self.metadata["review_notes"] = []
            self.metadata["review_notes"].append({
                "notes": notes,
                "reviewed_by": str(reviewed_by.id),
                "reviewed_at": self.reviewed_at.isoformat()
            })
    
    def reject(self, reviewed_by: 'User', reason: str) -> None:
        """Reject the topic."""
        self.status = TopicStatus.REJECTED
        self.reviewed_by = reviewed_by.id
        self.reviewed_at = datetime.utcnow()
        self.metadata["rejection_reason"] = reason
    
    def merge_into(self, target_topic: 'Topic') -> None:
        """Merge this topic into another topic."""
        self.status = TopicStatus.MERGED
        self.metadata["merged_into"] = str(target_topic.id)
        self.metadata["merged_at"] = datetime.utcnow().isoformat()
    
    def add_to_cluster(self, cluster_id: uuid.UUID, confidence: float = 1.0) -> 'TopicClusterMember':
        """Add topic to a cluster."""
        from models.topic import TopicClusterMember
        
        membership = TopicClusterMember(
            topic_id=self.id,
            cluster_id=cluster_id,
            confidence_score=confidence
        )
        return membership
    
    def get_related_topics(self, relationship_type: Optional[str] = None) -> List['TopicRelationship']:
        """Get related topics."""
        if relationship_type:
            return [
                rel for rel in self.topic_relationships 
                if rel.relationship_type == relationship_type
            ]
        return self.topic_relationships
    
    def to_dict(self, include_children: bool = False, include_parent: bool = False) -> Dict[str, Any]:
        """Convert topic to dictionary."""
        result = {
            "id": str(self.id),
            "name": self.name,
            "slug": self.slug,
            "description": self.description,
            "type": self.type.value,
            "status": self.status.value,
            "source": self.source.value,
            "parent_topic_id": str(self.parent_topic_id) if self.parent_topic_id else None,
            "depth": self.depth,
            "language": self.language,
            "synonyms": self.synonyms,
            "keywords": self.keywords,
            "all_keywords": self.all_keywords,
            "weight": self.weight,
            "popularity_score": self.popularity_score,
            "relevance_score": self.relevance_score,
            "trend_score": self.trend_score,
            "overall_score": self.overall_score,
            "is_active": self.is_active,
            "is_pending_review": self.is_pending_review,
            "is_reviewed": self.is_reviewed,
            "is_root": self.is_root,
            "is_leaf": self.is_leaf,
            "is_featured": self.is_featured,
            "is_sensitive": self.is_sensitive,
            "is_nsfw": self.is_nsfw,
            "child_count": self.child_count,
            "descendant_count": self.descendant_count,
            "content_count": self.content_count,
            "full_path": self.full_path,
            "path_slugs": self.path_slugs,
            "color": self.color,
            "icon": self.icon,
            "image_url": self.image_url,
            "banner_url": self.banner_url,
            "created_by": str(self.created_by) if self.created_by else None,
            "reviewed_by": str(self.reviewed_by) if self.reviewed_by else None,
            "reviewed_at": self.reviewed_at.isoformat() if self.reviewed_at else None,
            "organization_id": str(self.organization_id) if self.organization_id else None,
            "metadata": self.metadata,
            "tags": self.tags,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
        
        if include_children and self.child_topics:
            result["children"] = [
                child.to_dict(include_children=False, include_parent=False)
                for child in self.child_topics
                if child.is_active
            ]
        
        if include_parent and self.parent_topic:
            result["parent"] = self.parent_topic.to_dict(include_children=False, include_parent=False)
        
        if self.creator:
            result["creator"] = {
                "id": str(self.creator.id),
                "username": self.creator.username
            }
        
        if self.reviewer:
            result["reviewer"] = {
                "id": str(self.reviewer.id),
                "username": self.reviewer.username
            }
        
        if self.organization:
            result["organization"] = {
                "id": str(self.organization.id),
                "name": self.organization.name,
                "slug": self.organization.slug
            }
        
        return result
    
    @classmethod
    def create(
        cls,
        name: str,
        slug: str,
        topic_type: TopicType,
        created_by: Optional[uuid.UUID] = None,
        description: Optional[str] = None,
        parent_topic_id: Optional[uuid.UUID] = None,
        language: str = "en",
        synonyms: Optional[List[str]] = None,
        keywords: Optional[List[str]] = None,
        is_featured: bool = False,
        is_sensitive: bool = False,
        color: Optional[str] = None,
        icon: Optional[str] = None,
        organization_id: Optional[uuid.UUID] = None,
        metadata: Optional[Dict[str, Any]] = None,
        tags: Optional[List[str]] = None,
        source: TopicSource = TopicSource.MANUAL,
        **kwargs
    ) -> 'Topic':
        """
        Factory method to create a new topic.
        
        Args:
            name: Topic name
            slug: Topic slug
            topic_type: Type of topic
            created_by: User who created topic
            description: Topic description
            parent_topic_id: Parent topic ID
            language: Topic language
            synonyms: List of synonyms
            keywords: List of keywords
            is_featured: Whether topic is featured
            is_sensitive: Whether topic is sensitive
            color: Color code
            icon: Icon name/URL
            organization_id: Owning organization
            metadata: Additional metadata
            tags: Categorization tags
            source: Source of topic creation
            **kwargs: Additional arguments
            
        Returns:
            A new Topic instance
        """
        # Calculate depth
        depth = 0
        if parent_topic_id:
            # In real implementation, would fetch parent to get depth
            depth = 1  # Default, would be parent.depth + 1
        
        topic = cls(
            name=name.strip(),
            slug=slug.strip().lower(),
            type=topic_type,
            description=description,
            parent_topic_id=parent_topic_id,
            depth=depth,
            language=language,
            synonyms=synonyms or [],
            keywords=keywords or [],
            is_featured=is_featured,
            is_sensitive=is_sensitive,
            color=color,
            icon=icon,
            created_by=created_by,
            organization_id=organization_id,
            metadata=metadata or {},
            tags=tags or [],
            source=source,
            status=TopicStatus.PENDING if source != TopicSource.SYSTEM_GENERATED else TopicStatus.ACTIVE,
            **kwargs
        )
        
        return topic


class TopicAlias(Base, UUIDMixin, TimestampMixin):
    """
    Topic alias model for alternative names and translations.
    
    This model stores alternative names, translations, and
    variations of topics for better search and discovery.
    
    Attributes:
        id: Primary key UUID
        topic_id: Topic ID
        name: Alias name
        language: Alias language code
        type: Type of alias
        is_primary: Whether this is primary alias for language
        confidence: Confidence score (0-1)
        source: Source of alias
        metadata: Additional metadata
    """
    
    __tablename__ = "topic_aliases"
    
    topic_id = Column(
        UUID(as_uuid=True), 
        ForeignKey("topics.id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    
    # Alias information
    name = Column(String(200), nullable=False, index=True)
    language = Column(String(10), nullable=False, index=True)
    type = Column(String(50), default="translation", nullable=False, index=True)
    
    # Status
    is_primary = Column(Boolean, default=False, nullable=False, index=True)
    confidence = Column(Float, default=1.0, nullable=False)
    
    # Source
    source = Column(String(50), nullable=True)
    
    # Metadata
    metadata = Column(JSONB, default=dict, nullable=False)
    
    # Relationships
    topic = relationship("Topic", back_populates="topic_aliases")
    
    # Check constraints
    __table_args__ = (
        UniqueConstraint('topic_id', 'name', 'language', name='uq_topic_alias'),
        CheckConstraint('confidence >= 0 AND confidence <= 1', name='check_confidence_range'),
        Index('ix_topic_aliases_language_primary', 'language', 'is_primary'),
    )
    
    def __repr__(self) -> str:
        """String representation."""
        return f"<TopicAlias(id={self.id}, topic={self.topic_id}, name={self.name}, language={self.language})>"
    
    @property
    def is_translation(self) -> bool:
        """Check if alias is a translation."""
        return self.type == "translation"
    
    @property
    def is_synonym(self) -> bool:
        """Check if alias is a synonym."""
        return self.type == "synonym"
    
    @property
    def is_abbreviation(self) -> bool:
        """Check if alias is an abbreviation."""
        return self.type == "abbreviation"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert topic alias to dictionary."""
        return {
            "id": str(self.id),
            "topic_id": str(self.topic_id),
            "name": self.name,
            "language": self.language,
            "type": self.type,
            "is_primary": self.is_primary,
            "is_translation": self.is_translation,
            "is_synonym": self.is_synonym,
            "is_abbreviation": self.is_abbreviation,
            "confidence": self.confidence,
            "source": self.source,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }


class TopicRelationship(Base, UUIDMixin, TimestampMixin):
    """
    Topic relationship model.
    
    This model defines relationships between topics, such as
    hierarchical, associative, or semantic relationships.
    
    Attributes:
        id: Primary key UUID
        source_topic_id: Source topic ID
        target_topic_id: Target topic ID
        relationship_type: Type of relationship
        strength: Relationship strength (0-1)
        confidence: Confidence score (0-1)
        directionality: Direction of relationship
        metadata: Additional metadata
    """
    
    __tablename__ = "topic_relationships"
    
    # Topics
    source_topic_id = Column(
        UUID(as_uuid=True), 
        ForeignKey("topics.id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    target_topic_id = Column(
        UUID(as_uuid=True), 
        ForeignKey("topics.id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    
    # Relationship details
    relationship_type = Column(String(100), nullable=False, index=True)
    strength = Column(Float, default=1.0, nullable=False)
    confidence = Column(Float, default=1.0, nullable=False)
    directionality = Column(String(20), default="bidirectional", nullable=False)  # unidirectional, bidirectional
    
    # Metadata
    metadata = Column(JSONB, default=dict, nullable=False)
    
    # Relationships
    source_topic = relationship("Topic", foreign_keys=[source_topic_id], back_populates="topic_relationships")
    target_topic = relationship("Topic", foreign_keys=[target_topic_id], back_populates="related_topic_relationships")
    
    # Check constraints
    __table_args__ = (
        UniqueConstraint('source_topic_id', 'target_topic_id', 'relationship_type', name='uq_topic_relationship'),
        CheckConstraint('source_topic_id != target_topic_id', name='check_different_topics'),
        CheckConstraint('strength >= 0 AND strength <= 1', name='check_strength_range'),
        CheckConstraint('confidence >= 0 AND confidence <= 1', name='check_confidence_range'),
        Index('ix_topic_relationships_type_strength', 'relationship_type', 'strength'),
    )
    
    def __repr__(self) -> str:
        """String representation."""
        return f"<TopicRelationship(id={self.id}, source={self.source_topic_id}, target={self.target_topic_id}, type={self.relationship_type})>"
    
    @property
    def is_bidirectional(self) -> bool:
        """Check if relationship is bidirectional."""
        return self.directionality == "bidirectional"
    
    @property
    def is_unidirectional(self) -> bool:
        """Check if relationship is unidirectional."""
        return self.directionality == "unidirectional"
    
    @classmethod
    def create_relationship(
        cls,
        source_topic_id: uuid.UUID,
        target_topic_id: uuid.UUID,
        relationship_type: str,
        strength: float = 1.0,
        confidence: float = 1.0,
        directionality: str = "bidirectional",
        metadata: Optional[Dict[str, Any]] = None
    ) -> 'TopicRelationship':
        """Create a topic relationship."""
        return cls(
            source_topic_id=source_topic_id,
            target_topic_id=target_topic_id,
            relationship_type=relationship_type,
            strength=strength,
            confidence=confidence,
            directionality=directionality,
            metadata=metadata or {}
        )
    
    def to_dict(self, include_topics: bool = False) -> Dict[str, Any]:
        """Convert topic relationship to dictionary."""
        result = {
            "id": str(self.id),
            "source_topic_id": str(self.source_topic_id),
            "target_topic_id": str(self.target_topic_id),
            "relationship_type": self.relationship_type,
            "strength": self.strength,
            "confidence": self.confidence,
            "directionality": self.directionality,
            "is_bidirectional": self.is_bidirectional,
            "is_unidirectional": self.is_unidirectional,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
        
        if include_topics:
            if self.source_topic:
                result["source_topic"] = {
                    "id": str(self.source_topic.id),
                    "name": self.source_topic.name,
                    "slug": self.source_topic.slug
                }
            if self.target_topic:
                result["target_topic"] = {
                    "id": str(self.target_topic.id),
                    "name": self.target_topic.name,
                    "slug": self.target_topic.slug
                }
        
        return result


class ContentTopic(Base, UUIDMixin, TimestampMixin):
    """
    Content-topic association model.
    
    This model associates content with topics and stores
    relevance scores and other metadata.
    
    Attributes:
        id: Primary key UUID
        topic_id: Topic ID
        content_type: Type of content
        content_id: Content ID
        relevance_score: Relevance score (0-1)
        confidence: Confidence score (0-1)
        extraction_method: How association was determined
        is_primary: Whether this is primary topic for content
        position: Position/order of topic for this content
        metadata: Additional metadata
    """
    
    __tablename__ = "content_topics"
    
    # Topic and content
    topic_id = Column(
        UUID(as_uuid=True), 
        ForeignKey("topics.id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    content_type = Column(SQLEnum(ContentType), nullable=False, index=True)
    content_id = Column(UUID(as_uuid=True), nullable=False, index=True)
    
    # Association details
    relevance_score = Column(Float, default=1.0, nullable=False)
    confidence = Column(Float, default=1.0, nullable=False)
    extraction_method = Column(String(100), nullable=True)
    
    # Status and ordering
    is_primary = Column(Boolean, default=False, nullable=False, index=True)
    position = Column(Integer, default=0, nullable=False)
    
    # Metadata
    metadata = Column(JSONB, default=dict, nullable=False)
    
    # Relationships
    topic = relationship("Topic", back_populates="content_associations")
    
    # Check constraints
    __table_args__ = (
        UniqueConstraint('content_type', 'content_id', 'topic_id', name='uq_content_topic'),
        CheckConstraint('relevance_score >= 0 AND relevance_score <= 1', name='check_relevance_range'),
        CheckConstraint('confidence >= 0 AND confidence <= 1', name='check_confidence_range'),
        CheckConstraint('position >= 0', name='check_position_non_negative'),
        Index('ix_content_topics_content', 'content_type', 'content_id'),
        Index('ix_content_topics_relevance', 'topic_id', 'relevance_score'),
    )
    
    def __repr__(self) -> str:
        """String representation."""
        return f"<ContentTopic(id={self.id}, topic={self.topic_id}, content={self.content_type.value}:{self.content_id})>"
    
    @property
    def composite_id(self) -> str:
        """Get composite content identifier."""
        return f"{self.content_type.value}:{self.content_id}"
    
    @classmethod
    def associate_content(
        cls,
        topic_id: uuid.UUID,
        content_type: ContentType,
        content_id: uuid.UUID,
        relevance_score: float = 1.0,
        confidence: float = 1.0,
        extraction_method: Optional[str] = None,
        is_primary: bool = False,
        position: int = 0,
        metadata: Optional[Dict[str, Any]] = None
    ) -> 'ContentTopic':
        """Associate content with a topic."""
        return cls(
            topic_id=topic_id,
            content_type=content_type,
            content_id=content_id,
            relevance_score=relevance_score,
            confidence=confidence,
            extraction_method=extraction_method,
            is_primary=is_primary,
            position=position,
            metadata=metadata or {}
        )
    
    def to_dict(self, include_topic: bool = False) -> Dict[str, Any]:
        """Convert content-topic association to dictionary."""
        result = {
            "id": str(self.id),
            "topic_id": str(self.topic_id),
            "content_type": self.content_type.value,
            "content_id": str(self.content_id),
            "composite_id": self.composite_id,
            "relevance_score": self.relevance_score,
            "confidence": self.confidence,
            "extraction_method": self.extraction_method,
            "is_primary": self.is_primary,
            "position": self.position,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
        
        if include_topic and self.topic:
            result["topic"] = {
                "id": str(self.topic.id),
                "name": self.topic.name,
                "slug": self.topic.slug
            }
        
        return result


class UserTopicInterest(Base, UUIDMixin, TimestampMixin):
    """
    User topic interest model.
    
    This model tracks user interests in topics for personalization
    and recommendation purposes.
    
    Attributes:
        id: Primary key UUID
        user_id: User ID
        topic_id: Topic ID
        interest_score: Interest score (0-1)
        confidence: Confidence in interest score (0-1)
        interaction_count: Number of interactions
        last_interaction_at: Last interaction timestamp
        decay_factor: Score decay factor
        metadata: Additional metadata
    """
    
    __tablename__ = "user_topic_interests"
    
    # User and topic
    user_id = Column(
        UUID(as_uuid=True), 
        ForeignKey("users.id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    topic_id = Column(
        UUID(as_uuid=True), 
        ForeignKey("topics.id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    
    # Interest scoring
    interest_score = Column(Float, default=0.0, nullable=False)
    confidence = Column(Float, default=0.0, nullable=False)
    interaction_count = Column(Integer, default=0, nullable=False)
    last_interaction_at = Column(DateTime(timezone=True), nullable=True)
    decay_factor = Column(Float, default=0.95, nullable=False)  # Per week decay
    
    # Metadata
    metadata = Column(JSONB, default=dict, nullable=False)
    
    # Relationships
    user = relationship("User")
    topic = relationship("Topic", back_populates="user_interests")
    
    # Check constraints
    __table_args__ = (
        UniqueConstraint('user_id', 'topic_id', name='uq_user_topic_interest'),
        CheckConstraint('interest_score >= 0 AND interest_score <= 1', name='check_interest_score_range'),
        CheckConstraint('confidence >= 0 AND confidence <= 1', name='check_confidence_range'),
        CheckConstraint('interaction_count >= 0', name='check_interaction_count_non_negative'),
        CheckConstraint('decay_factor >= 0 AND decay_factor <= 1', name='check_decay_factor_range'),
        Index('ix_user_topic_interests_score', 'user_id', 'interest_score'),
        Index('ix_user_topic_interests_recent', 'user_id', 'last_interaction_at'),
    )
    
    def __repr__(self) -> str:
        """String representation."""
        return f"<UserTopicInterest(id={self.id}, user={self.user_id}, topic={self.topic_id}, score={self.interest_score})>"
    
    @property
    def days_since_last_interaction(self) -> Optional[int]:
        """Get days since last interaction."""
        if not self.last_interaction_at:
            return None
        delta = datetime.utcnow() - self.last_interaction_at
        return delta.days
    
    @property
    def decayed_score(self) -> float:
        """Get interest score with decay applied."""
        if not self.last_interaction_at:
            return self.interest_score
        
        weeks_since = (datetime.utcnow() - self.last_interaction_at).days / 7
        decayed = self.interest_score * (self.decay_factor ** weeks_since)
        return max(0.0, min(1.0, decayed))
    
    def record_interaction(self, interaction_weight: float = 0.1) -> None:
        """Record user interaction with this topic."""
        self.interaction_count += 1
        self.last_interaction_at = datetime.utcnow()
        
        # Update interest score with exponential moving average
        new_score = self.interest_score + interaction_weight * (1.0 - self.interest_score)
        self.interest_score = min(1.0, new_score)
        
        # Increase confidence with interactions
        self.confidence = min(1.0, self.confidence + 0.05)
    
    def decay_score(self) -> None:
        """Apply decay to interest score."""
        self.interest_score = self.decayed_score
    
    def to_dict(self, include_topic: bool = False, include_user: bool = False) -> Dict[str, Any]:
        """Convert user topic interest to dictionary."""
        result = {
            "id": str(self.id),
            "user_id": str(self.user_id),
            "topic_id": str(self.topic_id),
            "interest_score": self.interest_score,
            "decayed_score": self.decayed_score,
            "confidence": self.confidence,
            "interaction_count": self.interaction_count,
            "last_interaction_at": self.last_interaction_at.isoformat() if self.last_interaction_at else None,
            "days_since_last_interaction": self.days_since_last_interaction,
            "decay_factor": self.decay_factor,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
        
        if include_topic and self.topic:
            result["topic"] = {
                "id": str(self.topic.id),
                "name": self.topic.name,
                "slug": self.topic.slug
            }
        
        if include_user and self.user:
            result["user"] = {
                "id": str(self.user.id),
                "username": self.user.username
            }
        
        return result


class TopicCluster(Base, UUIDMixin, TimestampMixin):
    """
    Topic cluster model.
    
    This model represents clusters of related topics discovered
    through machine learning or manual grouping.
    
    Attributes:
        id: Primary key UUID
        name: Cluster name
        description: Cluster description
        cluster_method: Method used for clustering
        quality_score: Cluster quality score (0-1)
        size: Number of topics in cluster
        centroid_vector: Cluster centroid (for vector-based clustering)
        metadata: Additional metadata
    """
    
    __tablename__ = "topic_clusters"
    
    # Cluster information
    name = Column(String(200), nullable=False, index=True)
    description = Column(Text, nullable=True)
    cluster_method = Column(String(100), nullable=False, index=True)
    quality_score = Column(Float, nullable=True)
    
    # Statistics
    size = Column(Integer, default=0, nullable=False)
    
    # Vector data (for ML-based clustering)
    centroid_vector = Column(ARRAY(Float), nullable=True)
    
    # Metadata
    metadata = Column(JSONB, default=dict, nullable=False)
    tags = Column(ARRAY(String), default=[], nullable=False, index=True)
    
    # Relationships
    members = relationship("TopicClusterMember", back_populates="cluster", cascade="all, delete-orphan")
    
    # Check constraints
    __table_args__ = (
        CheckConstraint('quality_score IS NULL OR (quality_score >= 0 AND quality_score <= 1)', name='check_quality_score_range'),
        CheckConstraint('size >= 0', name='check_size_non_negative'),
    )
    
    def __repr__(self) -> str:
        """String representation."""
        return f"<TopicCluster(id={self.id}, name={self.name}, size={self.size})>"
    
    @property
    def average_confidence(self) -> float:
        """Get average confidence of cluster members."""
        if not self.members or self.size == 0:
            return 0.0
        total_confidence = sum(m.confidence_score for m in self.members)
        return total_confidence / self.size
    
    @property
    def topic_ids(self) -> List[uuid.UUID]:
        """Get list of topic IDs in cluster."""
        return [m.topic_id for m in self.members]
    
    def add_member(self, topic_id: uuid.UUID, confidence_score: float = 1.0) -> 'TopicClusterMember':
        """Add a topic to the cluster."""
        from models.topic import TopicClusterMember
        
        member = TopicClusterMember(
            cluster_id=self.id,
            topic_id=topic_id,
            confidence_score=confidence_score
        )
        self.members.append(member)
        self.size += 1
        return member
    
    def remove_member(self, topic_id: uuid.UUID) -> bool:
        """Remove a topic from the cluster."""
        for member in self.members:
            if member.topic_id == topic_id:
                self.members.remove(member)
                self.size -= 1
                return True
        return False
    
    def to_dict(self, include_members: bool = False) -> Dict[str, Any]:
        """Convert topic cluster to dictionary."""
        result = {
            "id": str(self.id),
            "name": self.name,
            "description": self.description,
            "cluster_method": self.cluster_method,
            "quality_score": self.quality_score,
            "size": self.size,
            "average_confidence": self.average_confidence,
            "metadata": self.metadata,
            "tags": self.tags,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
        
        if include_members and self.members:
            result["members"] = [
                member.to_dict(include_topic=True, include_cluster=False)
                for member in self.members
            ]
            result["topic_ids"] = self.topic_ids
        
        return result


class TopicClusterMember(Base, UUIDMixin, TimestampMixin):
    """
    Topic cluster member model.
    
    This model represents membership of a topic in a cluster.
    
    Attributes:
        id: Primary key UUID
        cluster_id: Cluster ID
        topic_id: Topic ID
        confidence_score: Confidence in membership (0-1)
        distance_to_centroid: Distance to cluster centroid
        metadata: Additional metadata
    """
    
    __tablename__ = "topic_cluster_members"
    
    # Cluster and topic
    cluster_id = Column(
        UUID(as_uuid=True), 
        ForeignKey("topic_clusters.id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    topic_id = Column(
        UUID(as_uuid=True), 
        ForeignKey("topics.id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    
    # Membership details
    confidence_score = Column(Float, default=1.0, nullable=False)
    distance_to_centroid = Column(Float, nullable=True)
    
    # Metadata
    metadata = Column(JSONB, default=dict, nullable=False)
    
    # Relationships
    cluster = relationship("TopicCluster", back_populates="members")
    topic = relationship("Topic", back_populates="cluster_memberships")
    
    # Check constraints
    __table_args__ = (
        UniqueConstraint('cluster_id', 'topic_id', name='uq_cluster_topic'),
        CheckConstraint('confidence_score >= 0 AND confidence_score <= 1', name='check_confidence_range'),
        Index('ix_cluster_members_confidence', 'cluster_id', 'confidence_score'),
    )
    
    def __repr__(self) -> str:
        """String representation."""
        return f"<TopicClusterMember(id={self.id}, cluster={self.cluster_id}, topic={self.topic_id}, confidence={self.confidence_score})>"
    
    def to_dict(self, include_topic: bool = False, include_cluster: bool = False) -> Dict[str, Any]:
        """Convert topic cluster member to dictionary."""
        result = {
            "id": str(self.id),
            "cluster_id": str(self.cluster_id),
            "topic_id": str(self.topic_id),
            "confidence_score": self.confidence_score,
            "distance_to_centroid": self.distance_to_centroid,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
        
        if include_topic and self.topic:
            result["topic"] = {
                "id": str(self.topic.id),
                "name": self.topic.name,
                "slug": self.topic.slug
            }
        
        if include_cluster and self.cluster:
            result["cluster"] = {
                "id": str(self.cluster.id),
                "name": self.cluster.name
            }
        
        return result


class TopicTrend(Base, UUIDMixin, TimestampMixin):
    """
    Topic trend model.
    
    This model tracks trends and popularity of topics over time.
    
    Attributes:
        id: Primary key UUID
        topic_id: Topic ID
        period_start: Start of trend period
        period_end: End of trend period
        popularity_score: Popularity score for period
        growth_rate: Growth rate compared to previous period
        volume: Number of mentions/occurrences
        sentiment_score: Average sentiment (-1 to 1)
        metadata: Additional metadata
    """
    
    __tablename__ = "topic_trends"
    
    # Topic and period
    topic_id = Column(
        UUID(as_uuid=True), 
        ForeignKey("topics.id", ondelete="CASCADE"), 
        nullable=False,
        index=True
    )
    period_start = Column(DateTime(timezone=True), nullable=False, index=True)
    period_end = Column(DateTime(timezone=True), nullable=False, index=True)
    
    # Trend metrics
    popularity_score = Column(Float, default=0.0, nullable=False)
    growth_rate = Column(Float, default=0.0, nullable=False)
    volume = Column(Integer, default=0, nullable=False)
    sentiment_score = Column(Float, nullable=True)  # -1 to 1
    
    # Metadata
    metadata = Column(JSONB, default=dict, nullable=False)
    
    # Relationships
    topic = relationship("Topic")
    
    # Check constraints
    __table_args__ = (
        UniqueConstraint('topic_id', 'period_start', 'period_end', name='uq_topic_trend_period'),
        CheckConstraint('period_end > period_start', name='check_period_valid'),
        CheckConstraint('volume >= 0', name='check_volume_non_negative'),
        CheckConstraint('sentiment_score IS NULL OR (sentiment_score >= -1 AND sentiment_score <= 1)', name='check_sentiment_range'),
        Index('ix_topic_trends_period', 'period_start', 'period_end'),
        Index('ix_topic_trends_popularity', 'topic_id', 'popularity_score'),
    )
    
    def __repr__(self) -> str:
        """String representation."""
        return f"<TopicTrend(id={self.id}, topic={self.topic_id}, period={self.period_start} to {self.period_end})>"
    
    @property
    def period_duration_days(self) -> int:
        """Get period duration in days."""
        duration = self.period_end - self.period_start
        return duration.days
    
    @property
    def is_increasing(self) -> bool:
        """Check if trend is increasing."""
        return self.growth_rate > 0
    
    @property
    def is_decreasing(self) -> bool:
        """Check if trend is decreasing."""
        return self.growth_rate < 0
    
    @property
    def is_stable(self) -> bool:
        """Check if trend is stable."""
        return abs(self.growth_rate) < 0.01
    
    @property
    def average_daily_volume(self) -> float:
        """Get average daily volume."""
        if self.period_duration_days == 0:
            return float(self.volume)
        return self.volume / self.period_duration_days
    
    def to_dict(self, include_topic: bool = False) -> Dict[str, Any]:
        """Convert topic trend to dictionary."""
        result = {
            "id": str(self.id),
            "topic_id": str(self.topic_id),
            "period_start": self.period_start.isoformat(),
            "period_end": self.period_end.isoformat(),
            "period_duration_days": self.period_duration_days,
            "popularity_score": self.popularity_score,
            "growth_rate": self.growth_rate,
            "volume": self.volume,
            "sentiment_score": self.sentiment_score,
            "average_daily_volume": self.average_daily_volume,
            "is_increasing": self.is_increasing,
            "is_decreasing": self.is_decreasing,
            "is_stable": self.is_stable,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }
        
        if include_topic and self.topic:
            result["topic"] = {
                "id": str(self.topic.id),
                "name": self.topic.name,
                "slug": self.topic.slug
            }
        
        return result


class TopicExtractionJob(Base, UUIDMixin, TimestampMixin):
    """
    Topic extraction job model.
    
    This model tracks automated topic extraction jobs from content.
    
    Attributes:
        id: Primary key UUID
        status: Job status
        extraction_method: Method used for extraction
        content_type: Type of content processed
        content_ids: List of content IDs processed
        topics_extracted: Number of topics extracted
        confidence_threshold: Confidence threshold used
        started_at: When job started
        completed_at: When job completed
        error_message: Error message if failed
        metadata: Additional metadata
    """
    
    __tablename__ = "topic_extraction_jobs"
    
    # Job details
    status = Column(String(50), default="pending", nullable=False, index=True)
    extraction_method = Column(String(100), nullable=False)
    content_type = Column(SQLEnum(ContentType), nullable=False, index=True)
    
    # Content processed
    content_ids = Column(ARRAY(UUID(as_uuid=True)), default=[], nullable=False)
    
    # Results
    topics_extracted = Column(Integer, default=0, nullable=False)
    confidence_threshold = Column(Float, default=0.5, nullable=False)
    
    # Timing
    started_at = Column(DateTime(timezone=True), nullable=True)
    completed_at = Column(DateTime(timezone=True), nullable=True)
    
    # Error handling
    error_message = Column(Text, nullable=True)
    error_details = Column(JSONB, nullable=True)
    
    # Metadata
    metadata = Column(JSONB, default=dict, nullable=False)
    
    # Check constraints
    __table_args__ = (
        CheckConstraint('topics_extracted >= 0', name='check_topics_extracted_non_negative'),
        CheckConstraint('confidence_threshold >= 0 AND confidence_threshold <= 1', name='check_confidence_threshold_range'),
        Index('ix_topic_extraction_jobs_status', 'status', 'started_at'),
    )
    
    def __repr__(self) -> str:
        """String representation."""
        return f"<TopicExtractionJob(id={self.id}, method={self.extraction_method}, status={self.status})>"
    
    @property
    def is_completed(self) -> bool:
        """Check if job is completed."""
        return self.status == "completed"
    
    @property
    def is_failed(self) -> bool:
        """Check if job failed."""
        return self.status == "failed"
    
    @property
    def processing_time_seconds(self) -> Optional[float]:
        """Get processing time in seconds."""
        if self.started_at and self.completed_at:
            return (self.completed_at - self.started_at).total_seconds()
        return None
    
    @property
    def topics_per_content(self) -> float:
        """Get average topics per content item."""
        if not self.content_ids:
            return 0.0
        return self.topics_extracted / len(self.content_ids)
    
    def start(self) -> None:
        """Start the extraction job."""
        self.status = "processing"
        self.started_at = datetime.utcnow()
    
    def complete(self, topics_extracted: int) -> None:
        """Complete the extraction job."""
        self.status = "completed"
        self.completed_at = datetime.utcnow()
        self.topics_extracted = topics_extracted
    
    def fail(self, error_message: str, error_details: Optional[Dict[str, Any]] = None) -> None:
        """Mark job as failed."""
        self.status = "failed"
        self.completed_at = datetime.utcnow()
        self.error_message = error_message
        self.error_details = error_details
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert topic extraction job to dictionary."""
        return {
            "id": str(self.id),
            "status": self.status,
            "extraction_method": self.extraction_method,
            "content_type": self.content_type.value,
            "content_count": len(self.content_ids),
            "content_ids": [str(cid) for cid in self.content_ids],
            "topics_extracted": self.topics_extracted,
            "confidence_threshold": self.confidence_threshold,
            "topics_per_content": self.topics_per_content,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "processing_time_seconds": self.processing_time_seconds,
            "is_completed": self.is_completed,
            "is_failed": self.is_failed,
            "error_message": self.error_message,
            "error_details": self.error_details,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None
        }


# Association tables for many-to-many relationships
article_topics = Table(
    'article_topics',
    Base.metadata,
    Column('article_id', UUID(as_uuid=True), ForeignKey('articles.id'), primary_key=True),
    Column('topic_id', UUID(as_uuid=True), ForeignKey('topics.id'), primary_key=True),
    Column('created_at', DateTime(timezone=True), server_default=func.now()),
    Index('ix_article_topics_article', 'article_id'),
    Index('ix_article_topics_topic', 'topic_id')
)

incident_topics = Table(
    'incident_topics',
    Base.metadata,
    Column('incident_id', UUID(as_uuid=True), ForeignKey('incidents.id'), primary_key=True),
    Column('topic_id', UUID(as_uuid=True), ForeignKey('topics.id'), primary_key=True),
    Column('created_at', DateTime(timezone=True), server_default=func.now()),
    Index('ix_incident_topics_incident', 'incident_id'),
    Index('ix_incident_topics_topic', 'topic_id')
)

comment_topics = Table(
    'comment_topics',
    Base.metadata,
    Column('comment_id', UUID(as_uuid=True), ForeignKey('comments.id'), primary_key=True),
    Column('topic_id', UUID(as_uuid=True), ForeignKey('topics.id'), primary_key=True),
    Column('created_at', DateTime(timezone=True), server_default=func.now()),
    Index('ix_comment_topics_comment', 'comment_id'),
    Index('ix_comment_topics_topic', 'topic_id')
)

dataset_topics = Table(
    'dataset_topics',
    Base.metadata,
    Column('dataset_id', UUID(as_uuid=True), ForeignKey('datasets.id'), primary_key=True),
    Column('topic_id', UUID(as_uuid=True), ForeignKey('topics.id'), primary_key=True),
    Column('created_at', DateTime(timezone=True), server_default=func.now()),
    Index('ix_dataset_topics_dataset', 'dataset_id'),
    Index('ix_dataset_topics_topic', 'topic_id')
)


# Helper functions
def generate_topic_slug(name: str, existing_slugs: Optional[List[str]] = None) -> str:
    """Generate a URL-friendly slug from topic name."""
    import re
    import unicodedata
    
    # Normalize unicode
    name = unicodedata.normalize('NFKD', name)
    
    # Convert to lowercase and replace spaces with hyphens
    slug = re.sub(r'[^\w\s-]', '', name.lower())
    slug = re.sub(r'[-\s]+', '-', slug).strip('-')
    
    # Ensure slug only contains letters, numbers, and hyphens
    slug = re.sub(r'[^a-z0-9-]', '', slug)
    
    # If empty after cleaning, use a default
    if not slug:
        slug = "topic"
    
    # Make unique if existing_slugs provided
    if existing_slugs:
        base_slug = slug
        counter = 1
        while slug in existing_slugs:
            slug = f"{base_slug}-{counter}"
            counter += 1
    
    return slug


def calculate_topic_similarity(topic1: 'Topic', topic2: 'Topic') -> float:
    """Calculate similarity between two topics."""
    # Simple Jaccard similarity based on keywords
    keywords1 = set(topic1.all_keywords)
    keywords2 = set(topic2.all_keywords)
    
    if not keywords1 or not keywords2:
        return 0.0
    
    intersection = len(keywords1.intersection(keywords2))
    union = len(keywords1.union(keywords2))
    
    return intersection / union if union > 0 else 0.0


def extract_topics_from_text(
    text: str,
    existing_topics: List['Topic'],
    min_confidence: float = 0.7
) -> List[Dict[str, Any]]:
    """
    Extract topics from text using keyword matching.
    
    Note: This is a simple implementation. In production,
    you would use NLP libraries like spaCy, NLTK, or ML models.
    
    Args:
        text: Text to analyze
        existing_topics: List of existing topics to match against
        min_confidence: Minimum confidence threshold
        
    Returns:
        List of matched topics with confidence scores
    """
    import re
    
    text_lower = text.lower()
    matches = []
    
    for topic in existing_topics:
        if not topic.is_active:
            continue
        
        # Check for exact matches of topic name and synonyms
        search_terms = [topic.name.lower()] + [s.lower() for s in topic.synonyms]
        
        max_confidence = 0.0
        for term in search_terms:
            # Simple exact match (could be enhanced with fuzzy matching)
            if term in text_lower:
                # Calculate confidence based on term length and position
                term_confidence = min(1.0, len(term) / 20)  # Longer terms more confident
                max_confidence = max(max_confidence, term_confidence)
        
        if max_confidence >= min_confidence:
            matches.append({
                "topic": topic,
                "confidence": max_confidence,
                "matched_terms": [term for term in search_terms if term in text_lower]
            })
    
    # Sort by confidence
    matches.sort(key=lambda x: x["confidence"], reverse=True)
    
    return matches


def build_topic_hierarchy(topics: List['Topic']) -> List[Dict[str, Any]]:
    """Build hierarchical tree structure from flat list of topics."""
    # Create dictionary of topics by ID
    topics_by_id = {str(topic.id): topic for topic in topics}
    
    # Build tree
    tree = []
    for topic in topics:
        if not topic.parent_topic_id:
            # Root topic
            tree.append(_build_topic_node(topic, topics_by_id))
    
    return tree


def _build_topic_node(topic: 'Topic', topics_by_id: Dict[str, 'Topic']) -> Dict[str, Any]:
    """Recursively build topic node with children."""
    node = topic.to_dict(include_children=False, include_parent=False)
    
    # Find children
    children = []
    for potential_child in topics_by_id.values():
        if potential_child.parent_topic_id == topic.id:
            child_node = _build_topic_node(potential_child, topics_by_id)
            children.append(child_node)
    
    if children:
        node["children"] = children
    
    return node